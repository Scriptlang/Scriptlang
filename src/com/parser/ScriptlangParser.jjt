/**----------------**/
/** Parser options **/
/**----------------**/
options {
    LOOKAHEAD              = 1;
    CHOICE_AMBIGUITY_CHECK = 2;
    OTHER_AMBIGUITY_CHECK  = 1;
    STATIC                 = false;
    DEBUG_PARSER           = false;
    DEBUG_LOOKAHEAD        = false;
    DEBUG_TOKEN_MANAGER    = false;
    ERROR_REPORTING        = true;
    JAVA_UNICODE_ESCAPE    = false;
    UNICODE_INPUT          = false;
    IGNORE_CASE            = false;
    USER_TOKEN_MANAGER     = false;
    USER_CHAR_STREAM       = false;
    BUILD_PARSER           = true;
    BUILD_TOKEN_MANAGER    = true;
    SANITY_CHECK           = true;
    FORCE_LA_CHECK         = false;
    MULTI                  = true;
    NODE_EXTENDS           = "NodeSetter";
    TRACK_TOKENS           = true;
}

PARSER_BEGIN(ScriptlangParser) /** ScriptLangParser Class - BEGIN **/
package com.parser;

import com.parser.nodes.Node_TypePrimitive.TypePrimitive;
import com.parser.nodes.Node_TypeModifier.TypeModifier;
import com.parser.nodes.Node_Literal.LiteralType;
import com.parser.nodes.Node_Expression.ExpressionType;

public class ScriptlangParser {
    /** Get the root node of the AST **/
    public Node rootNode() {
    	return jjtree.rootNode();
    }
}

PARSER_END(ScriptlangParser) /** ScriptLangParser Class - END **/

/**--------------------**/
/** Token declarations **/
/**--------------------**/
SKIP :
{
	" "  |
	"\t" |
	"\n" |
	"\r"
}

/**----------**/
/** COMMENTS **/
/**----------**/
MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT                                      |
	< "/**" ~[ "/" ] > { input_stream.backup(1); } : IN_FORMAL_COMMENT |
	"/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: ( ~[ "\n", "\r" ] )* ( "\n" | "\r" | "\r\n" )? > : DEFAULT
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN :
{
	<FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN :
{
	<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT, IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT> MORE :
{
	< ~[] >
}

TOKEN : /**** IMPORTANT: !! DO NOT CHANGE THE TOKEN DECLARATION ORDER !! ****/
{
	/* Block unit tokens */
	<LBRACE: "{">
|	<RBRACE: "}">

	/* Primitive data types */
|	<U8:     "u8"     >
|	<U16:    "u16"    >
|	<U32:    "u32"    >
|	<U64:    "u64"    >
|	<I8:     "i8"     >
|	<I16:    "i16"    >
|	<I32:    "i32"    >
|	<I64:    "i64"    >
|	<F32:    "f32"    >
|	<F64:    "f64"    >
|	<BOOL:   "bool"   >
|	<CHAR:   "char"   >
|	<STRING: "string" >
|	<USIZE:  "usize"  >
|	<ISIZE:  "isize"  >
|	<AUTO:   "auto"   >
|   <ARRAY:  "array"  >
|   <TYPE:   "type"   >
|   <LITERAL_SUFFIX: ("i" | "u" | "f" | "uz" | "iz") (<DIGIT_DEC>)+>

	/* Literals */
|	<LITERAL_INT_BIN: "0b" (<DIGIT_BIN>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_INT_OCT: "0" (<DIGIT_OCT>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_INT_DEC: (<DIGIT_DEC>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_INT_HEX: "0x" (<DIGIT_HEX>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_FLOAT32: (<DIGIT_DEC>)+ "." (<DIGIT_DEC>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_FLOAT64: (<DIGIT_DEC>)+ "." (<DIGIT_DEC>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_BOOL:    ("true" | "false")>

	/* Keywords */
|	<FN:       "fn"      > /* Return type void for function declaration                     */
|	<CLASS:    "class"   > /* Class declaration                                             */
|	<STRUCT:   "struct"  > /* Struct declaration                                            */
|	<ENUM:     "enum"    > /* Enum declaration                                              */
|	<PUB:      "pub"     > /* Public modifier                                               */
|	<PRIV:     "priv"    > /* Private modifier                                              */
|	<IF:       "if"      > /* Start of an if statement                                      */
|	<ELSE:     "else"    > /* Start of an else branch of an if statement                    */
|	<SWITCH:   "switch"  > /* Start of a switch statement                                   */
|	<FOR:      "for"     > /* Start of a for loop statement                                 */
|	<WHILE:    "while"   > /* Start of a while loop statement                               */
|   <BREAK:    "break"   > /* Break out of a loop                                           */
|   <CONTINUE: "continue"> /* Jump to the next loop cycle                                   */
|   <RETURN:   "return"  > /* Return from a block unit                                      */
|	<BIND:     "@"       > /* Binds an identifier to a pattern (could be an anonymous bind) */

	/* Identifiers */
|	<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT_BIN> | <DIGIT_OCT> | <DIGIT_DEC> | <DIGIT_HEX>)*>
|	<CHARACTER_LITERAL:
		"'"
		( (~["'","\\","\n","\r"]) |
			("\\"
				( ["n","t","b","r","f","\\","'","\""] |
				  ["0"-"7"] ( ["0"-"7"] )? |
				  ["0"-"3"] ["0"-"7"] ["0"-"7"]
				)
			)
		)
		"'"
>
|	<STRING_LITERAL:
		"\""
		( (~["\"","\\","\n","\r"]) |
			("\\"
				( ["n","t","b","r","f","\\","'","\""] |
				  ["0"-"7"] ( ["0"-"7"] )? |
				  ["0"-"3"] ["0"-"7"] ["0"-"7"]
				)
			)
		)*
		"\"">
|	<#LETTER:    ["a"-"z", "A"-"Z", "_"]>
|	<#DIGIT_BIN: ["0"-"1"]>
|	<#DIGIT_OCT: ["0"-"7"]>
|	<#DIGIT_DEC: ["0"-"9"]>
|	<#DIGIT_HEX: ["0"-"9", "a"-"z", "A"-"F"]>
}

/**-----------------**/
/** Root production **/
/**-----------------**/
void _Root() : {}
{
	( _All() )* <EOF>
}

void _All() #void : /* Matches any kind of top level construct */
{ Token t = null; }
{
	/* A label */
	LOOKAHEAD(2) _Identifier() ":" | 

	/* Early declare primitive variables
	 * (REASON: when declaring duples the parser thinks the tuple type is an expression,
	 *  thus, we'll declare variables with tuple types before statements) */
	LOOKAHEAD(3) ( ( _Type_Modifier() )? _Type_Primitive_Tuple_TypesOnly() _Identifier() ( LOOKAHEAD(2) "," _Identifier() )* ( LOOKAHEAD(2) _Assignment() )? ) #_Declaration_Variable() ";" |
	
	/* Early declare function to resolve conflict with blockUnit (due to access modifiers) */
	LOOKAHEAD(3) ( _Type_Modifier() ( LOOKAHEAD(2) ( _Type_Primitive() | <FN> ) )? _Identifier() 
		"(" ( _Declaration_Parameter_List() )? ")" _BlockUnit() ) #_Declaration_Function() |
	
	/* A block unit -> {...} */
	LOOKAHEAD(4) _BlockUnit() |

	/* An object (of a class) */
	LOOKAHEAD(3) ( _Declaration_Object() _Declaration_VarObj_List() ) #_Declaration_Object() |
	//LOOKAHEAD(3) ( LOOKAHEAD(2) ( LOOKAHEAD(7) ( ( _Identifier() #_Expression() ) #_Statement_Expression() ) | _Declaration_Object() ";" ) )+  |
	
	/* Statements -> if, switch, for, while */
	LOOKAHEAD(2) _Statement() |
	
	/* Declarations -> variables, functions, classes, structs, enums */
	LOOKAHEAD(2) _Declaration() |

	/* An access modifier for the actual top level module */
	_Type_Modifier() ":"                               
}

/**-------------------------**/
/** Higher level constructs **/
/**-------------------------**/
void _BlockUnit() : {} /* Also known as an independent Compilation Unit / Module */
{
	( ( _Type_Modifier() )? _Identifier() )? ( "[" "]" )? <LBRACE> ( _All() )* <RBRACE>
}

void _Statement() #void : {} /* Any kind of statement goes here */
{
	";" #_Statement_Empty()              | /* Just a semicolon                         */
	LOOKAHEAD(3) _Statement_Switch()     | /* Switch statement                         */
	LOOKAHEAD(3) _Statement_If()         | /* If statement                             */
	LOOKAHEAD(3) _Statement_For()        | /* For statement                            */
	LOOKAHEAD(3) _Statement_While()      | /* While statement                          */
	LOOKAHEAD(2) _Statement_Expression() | /* Assignment statement                     */		
	_Statement_Flow()                      /* Statement that disturbs the program flow */
}

void _Declaration() #void : {} /* Any kind of declaration goes here */
{
	LOOKAHEAD(2) _Declaration_Variable() _Declaration_VarObj_List() ";" | /* Variables   */
	LOOKAHEAD(2) ( _Type_Modifier() )? _Declaration_Function()          | /* Functions   */
	LOOKAHEAD(2) ( _Type_Modifier() )? _Declaration_Class() ";"         | /* Classes     */
	LOOKAHEAD(2) ( _Type_Modifier() )? _Declaration_Struct() ";"        | /* Structures  */
	( _Type_Modifier() )? _Declaration_Enum() ";"                         /* Enumerators */
}

/**----------------------------------**/
/** Lower level *generic* constructs **/
/**----------------------------------**/
void _Declaration_Variable() : {} /* Variable declaration: <type> <var_name> <assignment>? ; */
{
	( _Type_Modifier() )? _Type_Primitive() _Identifier()
}

void _Declaration_Object() #void : {} /* Variable object declaration: <class> <obj_name> <assignment>? ; */
{
	( _Type_Modifier() )? _Identifier() #_Type_Primitive() _Identifier()
}

void _Declaration_VarObj_List() : {}
{
	( LOOKAHEAD(2) "," ( _Identifier() ( LOOKAHEAD(2) ( _Assignment_Operation() _Expression() #_Expression() ) #_Assignment() )? ) #_Declaration_VarObj_Single() )*
	( ";" | ( _Assignment_Operation() _Expression() #_Expression() ) #_Declaration_VarObj_Single() )
}

void _Declaration_Function() : {} /* Function declaration: (<type>|fn)? <IDENTIFIER> (<params>?) <blockunit> */
{
	( LOOKAHEAD(2) ( _Type_Primitive() | <FN> ) )? _Identifier() "(" ( _Declaration_Parameter_List() )? ")" _BlockUnit()
}

void _Declaration_Function_Lambda() : {} /* Function declaration: <type> <IDENTIFIER>? (<params>?) <blockunit>? */
{
	_Type_Primitive() ( _Identifier() )? "(" ( _Declaration_Parameter_List() )? ")" ( LOOKAHEAD(2) _BlockUnit() )?
}

void _Declaration_Struct() : {} /* Struct declaration: struct <IDENTIFIER> { <declaration>* } ; */
{
	<STRUCT> _Identifier() "{" ( _Declaration() )* "}"
}

void _Declaration_Class() : {} /* Class declaration: class <IDENTIFIER> ( : (<modif>? <IDENTIFIER> , ...)+ )? <blockunit> */
{
	<CLASS> _Identifier() ( ":" ( LOOKAHEAD(2) ( _Type_Modifier() )? _Identifier() ( "," )? )+ #_Declaration_Class_Inheritance() )? _BlockUnit()
}

void _Declaration_Enum() : {} /* Enum declaration: enum <IDENTIFIER>? { <enumbodylist>  } */
{
	<ENUM> ( _Identifier() )? "{" ( _Declaration_EnumBody_List() )? "}"
}

void _Declaration_EnumBody_List() #void : {} /* Enum body list declaration */
{
	( _Declaration_EnumBody() ( "," )? )+
}

void _Declaration_EnumBody() #void : {} /* Enum body declaration: <enumconstlist> | <struct> | <tuple> | <function> |  */
{	
	/* An enum can have ... */
	LOOKAHEAD(3) _Declaration_Tuple_Named()     | /* A named tuple (or anonymous) with types and expression */
	LOOKAHEAD(3) _Declaration_EnumBody_Struct() | /* A struct declaration                                   */
	_Declaration_EnumBody_Struct_Bodyless()     | /* A struct without a body                                */
	LOOKAHEAD(3) _Declaration_EnumBody_Const()  | /* A constant identifier                                  */
	_Declaration_Function_Lambda()                /* A function, which acts as a lambda                     */
}

void _Declaration_EnumBody_Const() : {} /* Enum body const declaration: <IDENTIFIER> <assignment>? */
{
	_Identifier() ( LOOKAHEAD(2) _Assignment() )?
}

void _Declaration_EnumBody_Struct() : {} /* Enum body struct declaration: <struct>? <IDENTIFIER> { <declaration>* } */
{
	( <STRUCT> )? _Identifier() "{" ( _Declaration() )* "}"
}

void _Declaration_EnumBody_Struct_Bodyless() : {} /* Enum body struct declaration: <struct> <IDENTIFIER> */
{
	<STRUCT> _Identifier()
}

void _Declaration_Tuple_Named() : {} /* Enum body tuple declaration: <IDENTIFIER>? (<type>, <expression>, <type>, ...) */
{
	( _Identifier() )? "(" ( ( LOOKAHEAD(3)  _Expression() | _Type_Primitive() ) #_Declaration_Tuple_Named_Arg() ( "," )? )+ ")"
}

void _Declaration_Bind() : {} /* Bind declaration: <IDENTIFIER>? | [<IDENTIFIER>,? <IDENTIFIER>,? ...] @ */
{
	( _Identifier() )? <BIND> |
	"[" ( ( LOOKAHEAD(2) _Identifier() | _Declaration_Bind() ) ( "," )? )+ "]" <BIND>
}

void _Declaration_TypeList() : {} /* Type list declaration: <type>, <type>, <type>, ... */
{
	(LOOKAHEAD(2) _Type_Primitive() ( "," )? )+
}

void _Declaration_Parameter_List() : {} /* Parameter list declaration: <type> <IDENTIFIER>, <type> <IDENTIFIER>, <type>, <type>, ... */
{
	( _Declaration_Parameter_Single() ( "," )? )+
}

void _Declaration_Parameter_Single() : {} /* Declaration of a single function argument: <type> <IDENTIFIER> */
{
	_Type_Primitive() ( LOOKAHEAD(2) _Identifier() )?
}

void _Declaration_Parameter_Caller_List() : {} /* Parameter list declaration: <IDENTIFIER>, <expression>, <IDENTIFIER>, ... */
{
	( _Expression() #_Declaration_Parameter_Caller_Single() ( "," )? )*
}

void _Declaration_Array() : {}
{
	( LOOKAHEAD(2) ( _Expression() #_Expression() ) #_Declaration_Array_Arg() ( "," ( LOOKAHEAD(2) _Expression() #_Expression() )? #_Declaration_Array_Arg() )* )+	
}

void _Expression() #void : {}
{
	LOOKAHEAD(3) _Expression_CondOr() |
	_Expression_Primary() _Assignment()
}

void _Assignment() : {} /* Assignment: <prim_expr>? <assign_operation> <expr> */
{
	( LOOKAHEAD(2) _Expression_Primary() )? _Assignment_Operation() _Expression() #_Expression()
}

void _Assignment_Operation() :
{ Token t; }
{
	( t="=" | t="*=" | t="/=" | t="+=" | t="-=" | t=">>=" | t="<<=" | t="&=" | t="|=" | t="^=" | t="%=" )
	{
		jjtThis.setIdentifier(t.image);
	}
}

void _Identifier() : /* An identifier. (variable/function name for example) */
{ Token t; }
{
	t = <IDENTIFIER>
	{
		jjtThis.setIdentifier(t.image);
	}
}

void _Literal() : /* Literal constants (signed/unsigned integer, float, boolean, char and string) */
{ Token t; }
{
	t = <LITERAL_INT_BIN>   { jjtThis.setLiteral(t.image, LiteralType.INT_BIN); } | /* Binary integer      */
	t = <LITERAL_INT_OCT>   { jjtThis.setLiteral(t.image, LiteralType.INT_OCT); } | /* Octal integer       */
	t = <LITERAL_INT_DEC>   { jjtThis.setLiteral(t.image, LiteralType.INT_DEC); } | /* Decimal integer     */
	t = <LITERAL_INT_HEX>   { jjtThis.setLiteral(t.image, LiteralType.INT_HEX); } | /* Hexadecimal integer */
	t = <LITERAL_FLOAT32>   { jjtThis.setLiteral(t.image, LiteralType.FLOAT32); } | /* 32-bit float        */
	t = <LITERAL_FLOAT64>   { jjtThis.setLiteral(t.image, LiteralType.FLOAT64); } | /* 64-bit float        */
	t = <LITERAL_BOOL>      { jjtThis.setLiteral(t.image, LiteralType.BOOL);    } | /* Boolean             */
	t = <CHARACTER_LITERAL> { jjtThis.setLiteral(t.image, LiteralType.CHAR);    } | /* Character           */
	t = <STRING_LITERAL>    { jjtThis.setLiteral(t.image, LiteralType.STRING);  }   /* String              */
}

/**
******************************************
******************************************
** Lower level *specialised* constructs **
******************************************
******************************************
**/

/**-------------**/
/** Expressions **/
/**-------------**/
void _Expression_CondOr() #void : {}
{
	_Expression_CondAnd() ( LOOKAHEAD(2) "||" _Expression_CondAnd() #_Expression() { jjtn001.setExpr("||", ExpressionType.CONDOR); } )*
}

void _Expression_CondAnd() #void : {}
{
	_Expression_IncOr() ( LOOKAHEAD(2) "&&" _Expression_IncOr() #_Expression() { jjtn001.setExpr("&&", ExpressionType.CONDAND); } )*
}

void _Expression_IncOr() #void : {}
{
	_Expression_ExOr() ( LOOKAHEAD(2) "|" _Expression_ExOr() #_Expression() { jjtn001.setExpr("|", ExpressionType.INCOR); } )*
}

void _Expression_ExOr() #void : {}
{
	_Expression_And() ( LOOKAHEAD(2) "^" _Expression_And() #_Expression() { jjtn001.setExpr("^", ExpressionType.EXOR); } )*
}

void _Expression_And() #void : {}
{
	_Expression_Equal() ( LOOKAHEAD(2) "&" _Expression_Equal() #_Expression() { jjtn001.setExpr("&", ExpressionType.AND); } )*
}

void _Expression_Equal() #void : {}
{
	_Expression_Relational()
	( LOOKAHEAD(2)
	  ( "==" _Expression_Relational() #_Expression() { jjtn001.setExpr("==", ExpressionType.EQUAL); } |
        "!=" _Expression_Relational() #_Expression() { jjtn002.setExpr("!=", ExpressionType.EQUAL); } ) )*
}

void _Expression_Relational() #void : {}
{
	_Expression_Shift() 
	( LOOKAHEAD(2)
	  ( "<"  _Expression_Shift() #_Expression() { jjtn001.setExpr("<",  ExpressionType.REL); } | 
	    ">"  _Expression_Shift() #_Expression() { jjtn002.setExpr(">",  ExpressionType.REL); } | 
	    "<=" _Expression_Shift() #_Expression() { jjtn003.setExpr("<=", ExpressionType.REL); } | 
	    ">=" _Expression_Shift() #_Expression() { jjtn004.setExpr(">=", ExpressionType.REL); } ) )*
}

void _Expression_Shift() #void : {}
{
	_Expression_Additive() 
	( LOOKAHEAD(2)
	  ( "<<"  _Expression_Additive() #_Expression() { jjtn001.setExpr("<<",  ExpressionType.SHT); } | 
	    ">>"  _Expression_Additive() #_Expression() { jjtn002.setExpr(">>",  ExpressionType.SHT); } ) )*
}

void _Expression_Additive() #void : {}
{
	_Expression_Multiplicative()
	( LOOKAHEAD(2)
	  ( "+" _Expression_Multiplicative() #_Expression() { jjtn001.setExpr("+",  ExpressionType.ADD); } |
        "-" _Expression_Multiplicative() #_Expression() { jjtn002.setExpr("-",  ExpressionType.ADD); } ) )*
}

void _Expression_Multiplicative() #void : {}
{
	_Expression_Cast()
	( LOOKAHEAD(2)
	  ( "*" _Expression_Cast() #_Expression() { jjtn001.setExpr("*",  ExpressionType.MUL); } |
        "/" _Expression_Cast() #_Expression() { jjtn002.setExpr("/",  ExpressionType.MUL); } |
	    "%" _Expression_Cast() #_Expression() { jjtn003.setExpr("%",  ExpressionType.MUL); } ) )*
}

void _Expression_Cast() #void :
{ Token t; }
{
	LOOKAHEAD(3) "(" t = _Type_Suffix() ")" ( LOOKAHEAD(2) _Expression_Unary() )? #_Expression()
	{
		jjtn001.setExpr("(" + t.image + ")", ExpressionType.CAST);
	} |
	_Expression_Unary()
}

void _Expression_Unary() #void : {}
{
	"++" _Expression_Unary() #_Expression() { jjtn001.setExpr("++", ExpressionType.UNARY); } |
	"--" _Expression_Unary() #_Expression() { jjtn002.setExpr("--", ExpressionType.UNARY); } |
	"~"  _Expression_Unary() #_Expression() { jjtn003.setExpr("~",  ExpressionType.UNARY); } |
	"!"  _Expression_Unary() #_Expression() { jjtn004.setExpr("!",  ExpressionType.UNARY); } |
	"+"  _Expression_Unary() #_Expression() { jjtn005.setExpr("+",  ExpressionType.UNARY); } |
	"-"  _Expression_Unary() #_Expression() { jjtn006.setExpr("-",  ExpressionType.UNARY); } |
	"*"  _Expression_Unary() #_Expression() { jjtn007.setExpr("*",  ExpressionType.UNARY); } |
	"&"  _Expression_Unary() #_Expression() { jjtn008.setExpr("&",  ExpressionType.UNARY); } |
	_Expression_Postfix()
}

void _Expression_Postfix() #void :
{ Token t = null, t2 = null, t3 = null, t4 = null; }
{
	_Expression_Primary()
		( LOOKAHEAD(2) (
				( /* Slice syntax */
					t = "[" ( _Expression() #_Declaration_Array_Slice_Start() )? 
						( t2 = ":" ( _Expression() #_Declaration_Array_Slice_End() )?
						( t3 = ":" ( _Expression() #_Declaration_Array_Slice_Skip() )? )?  )? 
					t4 = "]"
				) |
				
				/* Calling function syntax */
				t = "(" _Declaration_Parameter_Caller_List() t2 = ")" |
				
				t = "--"              | /* Decrementing             */
				t = "++"              | /* Incrementing             */
				t = "." _Identifier() | /* Accessing member         */
				t = "->" _Identifier()  /* Accessing pointer member */
					
		) #_Expression()
		{
			jjtn004.setExpr(
				t.image + 
					(t2 != null ? t2.image : "") + 
					(t3 != null ? t3.image : "") + 
					(t4 != null ? t4.image : ""),  
				ExpressionType.POST);
			t = t2 = t3 = t4 = null;
		} )*
}

void _Expression_Primary() #void : {} /* Primary Expression: <literal> | <identifier> <callerargs>? | ( expression ) | <blockunit> */
{
	LOOKAHEAD(2) _Identifier()                     |
	LOOKAHEAD(2) _Literal()                        |
	LOOKAHEAD(3) "(" _Expression_Wrapped() ")"     |
	LOOKAHEAD(3) "[" ( _Declaration_Array() )* "]" |
	LOOKAHEAD(2) _Type_Primitive()                 |
	LOOKAHEAD(2) _BlockUnit()                      |
	_Statement_If()                                |
	_Statement_Switch()                            |
	LOOKAHEAD(2) _Statement_For()                  |
	_Statement_While()
}

void _Expression_Wrapped() : {}
{
	( LOOKAHEAD(2) ( _Expression() #_Expression() ) #_Declaration_Tuple_Arg() ( "," ( LOOKAHEAD(2) _Expression() #_Expression() )? #_Declaration_Tuple_Arg() )* )+
}

/**------------**/
/** Statements **/
/**------------**/
void _Statement_Expression() : 
{ Token t = null; }
{
	 _Expression() #_Expression() ( LOOKAHEAD(2) _Assignment() )* ( LOOKAHEAD(2) t = ";" )?
	{
		jjtn001.setExpr("(null)", ExpressionType.BLOB, (t == null));
	}
}

void _Statement_If() : {} /* If statement: if ( <expression> ) (<blockunit>|{ <all> }) (else (<blockunit>|{<all>}))? */
{
	<IF> "(" _Expression() #_Expression() ")" ( LOOKAHEAD(3) _BlockUnit() | _All() ) #_Statement_If_True()
	( LOOKAHEAD(2) <ELSE> ( LOOKAHEAD(3) _BlockUnit() | _All() ) #_Statement_If_False() )?
}

void _Statement_Switch() : {} /* Switch statement: switch ( <match>+ ) { <switchline>+ } */
{
	<SWITCH> "(" ( ( _Statement_Switch_Match_Single() ( "," )? )+ ) #_Statement_Switch_Match_List() ")" "{" ( LOOKAHEAD(2) _Statement_Switch_Line() ( "," )? )+ #_Statement_Switch_Line_List() "}"
}

void _Statement_Switch_Line() : {} /* A whole switch line */
{
	/* Switch condition list of a single switch line */
	( _Declaration_Bind() ( <ELSE> | ( _Statement_Switch_Match_Single() ( "," )? )* ) ) #_Statement_Switch_Match_List() ":"
	
	/* Switch body list of a single switch line */
	( LOOKAHEAD(3) _BlockUnit() #_Statement_Switch_Line_Body_List() |
	( LOOKAHEAD(2) _Statement_Switch_Line_Body_Single() )+ #_Statement_Switch_Line_Body_List() )
}

void _Statement_Switch_Match_Single() : {} /* What a switch "matching container" / "line condition" can be matched against */
{
	/* Can be matched against... */
	LOOKAHEAD(3) _Expression() #_Expression() | /* An expression         */
	_Type_Primitive()                           /* A primitive data type */
}

void _Statement_Switch_Line_Body_Single() #void : /* The body of a single switch line */
{ Token t = null; }
{	
	/* A returnable and NON-returnable expression -> a + 1 + 2 + 3 + b  !OR!  a + 1 + 2 + 3 + b; */
	LOOKAHEAD(3) ( _Expression() ( LOOKAHEAD(2) t = ";" )? ) #_Expression()
		{
			jjtn001.setExpr("(null)", ExpressionType.BLOB, (t == null));
		} |

	LOOKAHEAD(3) _Statement()   | /* Statements -> if, switch, for, while                          */
	LOOKAHEAD(2) _Declaration()   /* Declarations -> variables, functions, classes, structs, enums */
}

void _Statement_For() : {} /* For statement: for (<declvar> : <expression> | <declvar>*;<expression>?;<expression>?) <blockunit>|<all>|; */
{
	<FOR> "("

		/* Foreach declaration: */
		( LOOKAHEAD(3) _Declaration_Variable() #_Statement_Foreach_InitBranch() ":" _Expression() #_Expression() |

		/* Normal for declaration:        */
		/* For loop initialization branch */
		( ( LOOKAHEAD(3) _Declaration_Variable() | _Assignment() ) ( "," )? )* #_Statement_For_InitBranch() ";"
		
		/* For loop condition branch */
		( _Expression() #_Expression() )? ";"

		/* For iteration branch */
		( _Expression() #_Expression() ( "," )? )* #_Statement_For_IterateBranch() ) ")"

	/* For loop body */
	( LOOKAHEAD(3) _BlockUnit() | _All() ) #_Statement_For_BodyBranch()
}

void _Statement_While() : {} /* While statement: while ( <expression> ) <blockunit>|<all>|; */
{
	<WHILE> "(" _Expression() #_Expression() ")" ( LOOKAHEAD(3) _BlockUnit() | _All() ) #_Statement_While_BodyBranch()
}

void _Statement_Flow() : 
{ Token t; }
{
	( t=<CONTINUE> | t=<BREAK> | t=<RETURN> )
	{
		jjtThis.setIdentifier(t.image);
	}
}

/**-------**/
/** Types **/
/**-------**/
void _Type_Primitive() : /* All primitive data types are declared here */
{ Token t = null; }
{
	_Type_Primitive_Tuple()  |
	( t=<U8>     | t=<U16>   | t=<U32>  | t=<U64>   |
	  t=<I8>     | t=<I16>   | t=<I32>  | t=<I64>   |
	  t=<F32>    | t=<F64>   | t=<BOOL> | t=<CHAR>  |
	  t=<STRING> | t=<USIZE> | t=<ISIZE>| t=<ARRAY> |
	  t=<AUTO>   | t=<TYPE> )
	{
		if(t != null)
			jjtThis.setTypePrimitive(t.image, TypePrimitive.values()[t.kind - U8 + 1]);
	}
}

void _Type_Primitive_Tuple() :
{}
{
	"(" ( LOOKAHEAD(2) ( LOOKAHEAD(3) _Type_Primitive() | _Expression() ) ( LOOKAHEAD(2) "," )? )* ")"
}

void _Type_Primitive_Tuple_TypesOnly() :
{}
{
	"(" ( LOOKAHEAD(2) _Type_Primitive() ( LOOKAHEAD(2) "," )? )* ")"
}

Token _Type_Suffix() #void : /* Supported data type suffixes */
{ Token t; }
{
	( t=<U8>     | t=<U16>  | t=<U32>   | t=<U64>   |
	  t=<I8>     | t=<I16>  | t=<I32>   | t=<I64>   |
	  t=<F32>    | t=<F64>  | t=<BOOL>  | t=<CHAR>  |
	  t=<STRING> |t=<USIZE> | t=<ISIZE> | t=<ARRAY> |
	  t=<AUTO>   | t=<TYPE> | t=<LITERAL_SUFFIX> )
	{
		return t;
	}
}

void _Type_Modifier() : /* Access modifiers go here (such as pub and priv (aka public and private)) */
{ Token t; }
{
	( t=<PUB> | t=<PRIV> )
	{
		jjtThis.setTypeModifier(t.image, TypeModifier.values()[t.kind - PUB + 1]);
	}
}