/**----------------**/
/** Parser options **/
/**----------------**/
options {
    LOOKAHEAD              = 1;
    CHOICE_AMBIGUITY_CHECK = 2;
    OTHER_AMBIGUITY_CHECK  = 1;
    STATIC                 = false;
    DEBUG_PARSER           = false;
    DEBUG_LOOKAHEAD        = false;
    DEBUG_TOKEN_MANAGER    = false;
    ERROR_REPORTING        = true;
    JAVA_UNICODE_ESCAPE    = false;
    UNICODE_INPUT          = false;
    IGNORE_CASE            = false;
    USER_TOKEN_MANAGER     = false;
    USER_CHAR_STREAM       = false;
    BUILD_PARSER           = true;
    BUILD_TOKEN_MANAGER    = true;
    SANITY_CHECK           = true;
    FORCE_LA_CHECK         = false;
    MULTI                  = true;
    NODE_EXTENDS           = "NodeSetter";
    TRACK_TOKENS           = true;
}

PARSER_BEGIN(ScriptlangParser) /** ScriptLangParser Class - BEGIN **/
package com.parser;

import com.parser.nodes.Node_TypePrimitive.TypePrimitive;
import com.parser.nodes.Node_TypeModifier.TypeModifier;
import com.parser.nodes.Node_Literal.LiteralType;
import com.parser.nodes.Node_Expression.ExpressionType;

public class ScriptlangParser {
    /** Get the root node of the AST **/
    public Node rootNode() {
    	return jjtree.rootNode();
    }
}

PARSER_END(ScriptlangParser) /** ScriptLangParser Class - END **/

/**--------------------**/
/** Token declarations **/
/**--------------------**/
SKIP :
{
	" "
|	"\t"
|	"\n"
|	"\r"
}

TOKEN : /* IMPORTANT: !! DO NOT CHANGE THE TOKEN DECLARATION ORDER !! */
{
	/* Block unit tokens */
	<LBRACE: "{">
|	<RBRACE: "}">

	/* Primitive data types */
|	<U8:    "u8"   >
|	<U16:   "u16"  >
|	<U32:   "u32"  >
|	<U64:   "u64"  >
|	<I8:    "i8"   >
|	<I16:   "i16"  >
|	<I32:   "i32"  >
|	<I64:   "i64"  >
|	<F32:   "f32"  >
|	<F64:   "f64"  >
|	<BOOL:  "bool" >
|	<CHAR:  "char" >
|	<USIZE: "usize">
|	<ISIZE: "isize">
|	<AUTO:  "auto" >
|   <ARRAY: "array">
|   <LITERAL_SUFFIX: ("i" | "u" | "f" | "uz" | "iz") (<DIGIT_DEC>)+>

	/* Literals */
|	<LITERAL_INT_BIN: "0b" (<DIGIT_BIN>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_INT_OCT: "0" (<DIGIT_OCT>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_INT_DEC: (<DIGIT_DEC>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_INT_HEX: "0x" (<DIGIT_HEX>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_FLOAT32: (<DIGIT_DEC>)+ "." (<DIGIT_DEC>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_FLOAT64: (<DIGIT_DEC>)+ "." (<DIGIT_DEC>)+ (<LITERAL_SUFFIX>)?>
|	<LITERAL_BOOL: ("true" | "false")>

	/* Keywords */
|	<FN:     "fn"    > /* Return type void for function declaration  */
|	<CLASS:  "class" > /* Class declaration                          */
|	<STRUCT: "struct"> /* Struct declaration                         */
|	<ENUM:   "enum"  > /* Enum declaration                           */
|	<PUB:    "pub"   > /* Public modifier                            */
|	<PRIV:   "priv"  > /* Private modifier                           */
|	<IF:     "if"    > /* Start of an if statement                   */
|	<ELSE:   "else"  > /* Start of an else branch of an if statement */

	/* Identifiers */
|	<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT_BIN> | <DIGIT_OCT> | <DIGIT_DEC> | <DIGIT_HEX>)*>
|	<#LETTER: ["a"-"z", "A"-"Z", "_"]>
|	<#DIGIT_BIN: ["0"-"1"]>
|	<#DIGIT_OCT: ["0"-"7"]>
|	<#DIGIT_DEC: ["0"-"9"]>
|	<#DIGIT_HEX: ["0"-"9", "a"-"z", "A"-"F"]>
}

/**-----------------**/
/** Root production **/
/**-----------------**/
void _Root() : {}
{
	( _All() )* <EOF>
}

void _All() #void : /* Matches any kind of top level construct */
{ Token t = null; }
{
	LOOKAHEAD(2) _BlockUnit()   | /* A block unit -> {...} */ 
	
	/* A returnable and NON-returnable expression -> a + 1 + 2 + 3 + b  !OR!  a + 1 + 2 + 3 + b; */
	LOOKAHEAD(3) _Expression() #_Expression() ( LOOKAHEAD(2) t = ";" )?
		{
			jjtn001.setExpr("(null)", ExpressionType.BLOB, (t == null));
		} |

	LOOKAHEAD(2) _Statement()   | /* Statements -> if, switch, for, while                           */
	LOOKAHEAD(2) _Declaration() | /* Declarations -> variables, functions, classes, structs, enums  */
	_Type_Modifier() ":"          /* An access modifier for the actual top level module             */
}

/**-------------------------**/
/** Higher level constructs **/
/**-------------------------**/
void _BlockUnit() : {}
{
    ( _Identifier() )? <LBRACE> ( _All() )* <RBRACE>
}

void _Statement() #void : {}
{
	";" |
	LOOKAHEAD(3) _Statement_Labeled()                    |
	LOOKAHEAD(2) _Expression_Primary() _Assignment() ";" |
	LOOKAHEAD(3) _Statement_If()                         |
	LOOKAHEAD(3) _Statement_Switch()                     | 
	LOOKAHEAD(3) _Statement_For()                        |
	_Statement_While()                  
}

void _Declaration() #void : {} /* Any kind of declaration goes here */
{
	LOOKAHEAD(2) _Declaration_Variable() | /* Variables   */
	LOOKAHEAD(2) _Declaration_Function() | /* Functions   */
	LOOKAHEAD(2) _Declaration_Class()    | /* Classes     */
	LOOKAHEAD(2) _Declaration_Struct()   | /* Structures  */
	_Declaration_Enum()                    /* Enumerators */
}

/**----------------------------------**/
/** Lower level *generic* constructs **/
/**----------------------------------**/
void _Declaration_Variable() : {} /* Variable declaration: <modif>? <type> <var_name> <assignment>? ; */
{
	( _Type_Modifier() )? _Type_Primitive() _Identifier() ( "," _Identifier() )* ( _Assignment() )? ";" 
}

void _Declaration_Function() : {} /* Function declaration: <modif>? (<type>|fn)? <IDENTIFIER> (<params>?) { <blockunit> } */
{
	( _Type_Modifier() )? ( _Type_Primitive() | <FN> )? _Identifier() "(" ( _Declaration_Parameter_List() )? ")" _BlockUnit()
}

void _Declaration_Function_Lambda() : {} /* Function declaration: <modif>? <type> <IDENTIFIER>? (<params>?) { <blockunit> } */
{
	( _Type_Modifier() )? _Type_Primitive() ( _Identifier() )? "(" ( _Declaration_Parameter_List() )? ")" _BlockUnit()
}

void _Declaration_Function_Lambda_Nomod() : {} /* Lambda declaration: <type> <IDENTIFIER>? (<params>?) <blockunit>? */
{
	_Type_Primitive() ( _Identifier() )? "(" ( _Declaration_Parameter_List() )? ")" (LOOKAHEAD(2) _BlockUnit() )?
}

void _Declaration_Struct() : {} /* Struct declaration: <modif>? struct <IDENTIFIER> { <declaration>* } ; */
{
	( _Type_Modifier() )? <STRUCT> _Identifier() "{" ( _Declaration() )* "}" ";"
}

void _Declaration_Class() : {} /* Class declaration: <modif>? class <IDENTIFIER> ( : (<modif>? <IDENTIFIER> , ...)+ )? <blockunit> */
{
	( _Type_Modifier() )? <CLASS> _Identifier() ( ":" ( LOOKAHEAD(2) ( _Type_Modifier() )? _Identifier() ( "," )? )+ #_Declaration_Class_Inheritance() )? _BlockUnit() ";"
}

void _Declaration_Enum() : {} /* Enum declaration: <modif>? enum <IDENTIFIER>? { <enumbodylist>  } */
{
	( _Type_Modifier() )? <ENUM> ( _Identifier() )? "{" ( _Declaration_EnumBody_List() )? "}" ";"
}

void _Declaration_EnumBody_List() #void : {} /* Enum body list declaration */
{
	( _Declaration_EnumBody() ( "," )? )+
}

void _Declaration_EnumBody() #void : {} /* Enum body declaration: <enumconstlist> | <struct> | <tuple> | <function>|  */
{	
	/* An enum can have ... */
	LOOKAHEAD(3) _Declaration_Tuple()           | /* A named tuple                      */
	LOOKAHEAD(3) _Declaration_EnumBody_Struct() | /* A struct declaration               */
	_Declaration_EnumBody_Struct_Bodyless()     | /* A struct without a body            */
	_Declaration_EnumBody_Const()               | /* A constant identifier              */
	_Declaration_Function_Lambda_Nomod()          /* A function, which acts as a lambda */
}

void _Declaration_EnumBody_Const() : {} /* Enum body const declaration: <IDENTIFIER> <assignment>?  */
{
	_Identifier() ( LOOKAHEAD(2) _Assignment() )?
}

void _Declaration_EnumBody_Struct() : {} /* Enum body struct declaration: <struct>? <IDENTIFIER> { <declaration>* } */
{
	( <STRUCT> )? _Identifier() "{" ( _Declaration() )* "}"
}

void _Declaration_EnumBody_Struct_Bodyless() : {} /* Enum body struct declaration: <struct> <IDENTIFIER> */
{
	<STRUCT> _Identifier()
}

void _Declaration_Tuple() : {} /* Enum body tuple declaration: <IDENTIFIER>? (<type>, <type>, ...) */
{
	( _Identifier() )? "(" ( _Declaration_TypeList() )+ ")"
}

void _Declaration_TypeList() : {} /* Type list declaration: <type>, <type>, <type>, ... */
{
	(LOOKAHEAD(2) _Type_Primitive() ( "," )? )+
}

void _Declaration_Parameter_List() : {} /* Parameter list declaration: <type> <IDENTIFIER>, <type> <IDENTIFIER>, <type>, <type>, ... */
{
	( _Declaration_Parameter_Single() ( "," )? )+
}

void _Declaration_Parameter_Single() : {} /* Declaration of a single function argument: <type> <IDENTIFIER> */
{
	_Type_Primitive() ( _Identifier() )?
}

void _Declaration_Parameter_Caller_List() : {} /* Parameter list declaration: <IDENTIFIER>, <expression>, <IDENTIFIER>, ... */
{
	( _Expression() #_Declaration_Parameter_Caller_Single() ( "," )? )*
}

void _Expression() #void : {}
{
	LOOKAHEAD(3) _Expression_CondOr() |
	_Expression_Primary() _Assignment()
}

void _Assignment() : {} /* Assignment: <prim_expr>? = <expr> */
{
	( _Expression_Primary() )? "=" _Expression()
}

void _Identifier() : /* An identifier. (variable/function name for example) */
{ Token t; }
{
	t = <IDENTIFIER>
	{
		jjtThis.setIdentifier(t.image);
	}
}

void _Literal() : /* Literal constants (signed/unsigned integer, float, boolean, char and string) */
{ Token t; }
{
	t = <LITERAL_INT_BIN> { jjtThis.setLiteral(t.image, LiteralType.INT_BIN); } | /* Binary integer      */
	t = <LITERAL_INT_OCT> { jjtThis.setLiteral(t.image, LiteralType.INT_OCT); } | /* Octal integer       */
	t = <LITERAL_INT_DEC> { jjtThis.setLiteral(t.image, LiteralType.INT_DEC); } | /* Decimal integer     */
	t = <LITERAL_INT_HEX> { jjtThis.setLiteral(t.image, LiteralType.INT_HEX); } | /* Hexadecimal integer */
	t = <LITERAL_FLOAT32> { jjtThis.setLiteral(t.image, LiteralType.FLOAT32); } | /* 32-bit float        */
	t = <LITERAL_FLOAT64> { jjtThis.setLiteral(t.image, LiteralType.FLOAT64); } | /* 64-bit float        */
	t = <LITERAL_BOOL>    { jjtThis.setLiteral(t.image, LiteralType.BOOL);    }   /* Boolean             */
}

/******************************************/
/**--------------------------------------**/
/** Lower level *specialised* constructs **/
/**--------------------------------------**/
/******************************************/

/**-------------**/
/** Expressions **/
/**-------------**/
void _Expression_CondOr() #void : {}
{
	_Expression_CondAnd() ( "||" _Expression_CondAnd() #_Expression() { jjtn001.setExpr("||", ExpressionType.CONDOR); } )*
}

void _Expression_CondAnd() #void : {}
{
	_Expression_IncOr() ( "&&" _Expression_IncOr() #_Expression() { jjtn001.setExpr("&&", ExpressionType.CONDAND); } )*
}

void _Expression_IncOr() #void : {}
{
	_Expression_ExOr() ( "|" _Expression_ExOr() #_Expression() { jjtn001.setExpr("|", ExpressionType.INCOR); } )*
}

void _Expression_ExOr() #void : {}
{
	_Expression_And() ( "^" _Expression_And() #_Expression() { jjtn001.setExpr("^", ExpressionType.EXOR); } )*
}

void _Expression_And() #void : {}
{
	_Expression_Equal() ( "&" _Expression_Equal() #_Expression() { jjtn001.setExpr("&", ExpressionType.AND); } )*
}

void _Expression_Equal() #void : {}
{
	_Expression_Relational()
	( "==" _Expression_Relational() #_Expression() { jjtn001.setExpr("==", ExpressionType.EQUAL); } |
      "!=" _Expression_Relational() #_Expression() { jjtn002.setExpr("!=", ExpressionType.EQUAL); } )*
}

void _Expression_Relational() #void : {}
{
	_Expression_Shift() 
	( "<"  _Expression_Shift() #_Expression() { jjtn001.setExpr("<",  ExpressionType.REL); } | 
	  ">"  _Expression_Shift() #_Expression() { jjtn002.setExpr(">",  ExpressionType.REL); } | 
	  "<=" _Expression_Shift() #_Expression() { jjtn003.setExpr("<=", ExpressionType.REL); } | 
	  ">=" _Expression_Shift() #_Expression() { jjtn004.setExpr(">=", ExpressionType.REL); } )*
}

void _Expression_Shift() #void : {}
{
	_Expression_Additive() 
	( "<<"  _Expression_Additive() #_Expression() { jjtn001.setExpr("<<",  ExpressionType.SHT); } | 
	  ">>"  _Expression_Additive() #_Expression() { jjtn002.setExpr(">>",  ExpressionType.SHT); } )*
}

void _Expression_Additive() #void : {}
{
	_Expression_Multiplicative()
	( "+" _Expression_Multiplicative() #_Expression() { jjtn001.setExpr("+",  ExpressionType.ADD); } |
      "-" _Expression_Multiplicative() #_Expression() { jjtn002.setExpr("-",  ExpressionType.ADD); } )*
}

void _Expression_Multiplicative() #void : {}
{
	_Expression_Cast()
	( "*" _Expression_Cast() #_Expression() { jjtn001.setExpr("*",  ExpressionType.MUL); } |
      "/" _Expression_Cast() #_Expression() { jjtn002.setExpr("/",  ExpressionType.MUL); } |
	  "%" _Expression_Cast() #_Expression() { jjtn003.setExpr("%",  ExpressionType.MUL); } )*
}

void _Expression_Cast() #void :
{ Token t; }
{
	LOOKAHEAD(2) "(" t = _Type_Suffix() ")" _Expression_Unary() #_Expression()
	{
		jjtn001.setExpr("(" + t.image + ")",  ExpressionType.CAST);
	} |
	_Expression_Unary()
}

void _Expression_Unary() #void : {}
{
	"~" _Expression_Unary() #_Expression() { jjtn001.setExpr("~",  ExpressionType.UNARY); } |
	"!" _Expression_Unary() #_Expression() { jjtn002.setExpr("!",  ExpressionType.UNARY); } |
	_Expression_Primary()
}

void _Expression_Primary() #void : {} /* Primary Expression: <literal> | <identifier> <callerargs>? | ( expression ) */
{
	_Literal() |
	LOOKAHEAD(2) _Identifier() ( LOOKAHEAD(2) "(" ( _Declaration_Parameter_Caller_List() ) ")" )? |
	"(" _Expression() ")" |
	_BlockUnit()
}

/**------------**/
/** Statements **/
/**------------**/
void _Statement_Labeled() : {}
{
	_Identifier() ":" _Statement()
}

void _Statement_If() : {} /* If statement: if ( <expression> ) (<blockunit>|{ <all> }) (else (<blockunit>|{<all>}))? */
{
	<IF> "(" _Expression() #_Expression() ")" ( LOOKAHEAD(3) _BlockUnit() | _All() ) #_Statement_If_True()
	( LOOKAHEAD(2) <ELSE> ( LOOKAHEAD(3) _BlockUnit() | _All() ) #_Statement_If_False() )?
}

void _Statement_Switch() : {}
{
	_Identifier() ":" _Statement()
}

void _Statement_For() : {}
{
	_Identifier() ":" _Statement()
}

void _Statement_While() : {}
{
	_Identifier() ":" _Statement()
}

/**-------**/
/** Types **/
/**-------**/
void _Type_Primitive() : /* All primitive data types are declared here */
{ Token t; }
{
	( t=<U8>    | t=<U16>   | t=<U32>  | t=<U64>  |
	  t=<I8>    | t=<I16>   | t=<I32>  | t=<I64>  |
	  t=<F32>   | t=<F64>   | t=<BOOL> | t=<CHAR> |
	  t=<USIZE> | t=<ISIZE> | t=<AUTO> | t=<ARRAY> )
	{
		jjtThis.setTypePrimitive(t.image, TypePrimitive.values()[t.kind - U8 + 1]);
	}
}

Token _Type_Suffix() #void : /* Supported data type suffixes */
{ Token t; }
{
	( t=<U8>    | t=<U16>   | t=<U32>  | t=<U64>   |
	  t=<I8>    | t=<I16>   | t=<I32>  | t=<I64>   |
	  t=<F32>   | t=<F64>   | t=<BOOL> | t=<CHAR>  |
	  t=<USIZE> | t=<ISIZE> | t=<AUTO> | t=<ARRAY> |
	  t=<LITERAL_SUFFIX> )
	{
		return t;
	}
}

void _Type_Modifier() : /* Access modifiers go here (such as pub and priv (aka public and private)) */
{ Token t; }
{
	( t=<PUB> | t=<PRIV> )
	{
		jjtThis.setTypeModifier(t.image, TypeModifier.values()[t.kind - PUB + 1]);
	}
}