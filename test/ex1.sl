fn foo(u8, u16 a) {

}

struct a {
	char a = 1;
};

class Myclass : pub a, priv b {
pub:
	pub fn Myclass() {
		1
	}

	fn public_function() {

	}

	u8 pubdata;

priv:
	fn private_function() {

	}

	u8 privdata;
};

pub:
u64 myval = 20+10;
priv:
char priv_val = 2;

pub enum Enumlist {
	ENUM1 = 1,
	ENUM2,
	ENUM3,
	struct Myfunc {

	},

	u32 foo(),

	Tuple(u8)
};

test:

	a;

myblock {
 


	yes {
		a+1
	}
}

if(a) {
	pub:

	1+2
}

wholeif:

if(b) truebranch {
	if(2) anothertruebranch {

	} else elsebranch {

	}
} else {

	if(2) anothertruebranch {

	} else elsebranch {

	}
}

switch(u8) {
	@1+2,3: { do(1); do2(2);
	char c;
		if(1) {

		}

	}

	@2: again(3);
	@u8: a();
}

switch(u8) {
	@1:
		char i;
		test();
		1

	@2+1,23: {
		u32 b;

	},
	@foo(1,2), bar(3,4): {

	}
}

char a = if(1) {};

char c = switch(a) { @1: a * n, @2: a*n, [n,n2]@3,2: a*n*n2  };

switch(var) {
	@1: one();
	@2: two();


	[a,b,c]@3:
		three();
		another();

	@4: {
		four();
		another();
	}
	@5,6,7:
		five();
		six();
		seven();

	@u8: isU8(); 

	@equalto(): lambdaMatch();

	@else: 
		none();
	@:
		none();
	[bindall]@:
		func(bindall);
}

for(;;);

for(;;) {

	continue;
}
for(;;) {

	break;
}

for(auto a:a);


for(auto v : arr) {

}


for(;;v--1, --v++);

c(1)
a->a(b,c,d)->a.b[2:3:4];

a+1=if(1) test { run(); } += 10 *= 2;

while(cond(arg1(2,3), arg2)) {
	--*&*yes() -= 2;
}


pub block {

}

pub enum {
	ENUM1,

	u8 mylambda() pub a {
		priv:
		u8 a = 1;
		u8 b = 2;
		a + b
	},
	ENUM2,
};

